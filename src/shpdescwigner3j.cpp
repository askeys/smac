/**
SMAC -- Shape Matching Analysis Code
(SMAC) Open Source Software License Copyright 2012 The Regents of the 
University of Michigan All rights reserved.

SMAC may contain modifications ("Contributions") provided, and to which
copyright is held, by various Contributors who have granted The Regents of the
University of Michigan the right to modify and/or distribute such Contributions.

You may redistribute, use, and create derivate works of SMAC, in source
and binary forms, provided you abide by the following conditions:

* Redistributions of source code must retain the above copyright notice, this
list of conditions, and the following disclaimer both in the code and
prominently in any materials provided with the distribution.

* Redistributions in binary form must reproduce the above copyright notice, this
list of conditions, and the following disclaimer in the documentation and/or
other materials provided with the distribution.

* Apart from the above required attributions, neither the name of the copyright
holder nor the names of LibTPS's contributors may be used to endorse or
promote products derived from this software without specific prior written
permission.

Disclaimer

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND/OR ANY
WARRANTIES THAT THIS SOFTWARE IS FREE OF INFRINGEMENT ARE DISCLAIMED.

IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*//*
 *  wignerdesc.cpp
 *  libsmac
 *
 *  Created by askeys on 2/10/09.
 *  Copyright 2009 __MyCompanyName__. All rights reserved.
 *
 */

#include "shpdescwigner3j.h"
#include "shpdescfourier.h"
#include <iostream>

#include <assert.h>
#include <cstdlib>
#include <limits>


namespace smac
{

#ifndef DOXYGEN_SHOULD_SKIP_THIS
	void w3j(double l1, double l2, double l3, double m1, double &m2min,
		double &m2max, double *thrcof, int ndim, int &errflag);
#endif


	/**
	\brief computes the wigner descriptor
	\ingroup shpdesc
	\param shape is the shape data (coordinates / weights)
	\param sd is an array to hold the result for each l
	*/
	void wigner3jdesc(shapedata_t& shape, shpdesc_t& sd, arg_t arg)
	{
		fourier_info* f = static_cast<fourier_info*>(arg);
		f->invariant = INVARIANT_W;
		fourierdesc3d(shape, sd, arg);
	}

	/**
	\brief compute the Wigner 3j coefficient for a 3d fourier coefficient
	\param sd is a 3d fourier coefficent for which to compute the 3j symbol
	\return w3j for the input coefficient
	*/
	double wigner3jcoeff(shpdesc_t&sd)
	{
		int l = (sd.size()-1) / 2;
		double w3jl[2*l + 1], m2min, m2max;										// minimum and maximum values of m2
		int errflag;
		component_t numerator;

		for (int m1=-l; m1<=l; m1++ ) {
			w3j(l, l, l, m1, m2min, m2max, w3jl, (2*l+1), errflag);
			if( errflag ) {
				std::cerr << " w3j: Error number " << errflag << std::endl;
				exit( 1 );
			}
			component_t temp;
			for (int m2 = int(m2min); m2<=int(m2max); m2++) {
				temp += sd[m2+l]*sd[l-m2-m1]*w3jl[m2-int(m2min)];
			}
			temp *= sd[m1+l];
			numerator += temp;
		}
		double wl = real(numerator);
		double denominator = 0.0;
		for (int m=-l; m<=l; m++) {
			denominator += real(sd[ m+l ])*real(sd[m+l]) +
				imag(sd[m+l])*imag(sd[m+l]);
		}
		if (denominator == 0.0) {
			wl = 0.0;
		}
		else {
			wl /= sqrt(denominator*denominator*denominator);
		}

		return wl;
	}

#ifndef DOXYGEN_SHOULD_SKIP_THIS
	/**
	\note This function is from MatPack with a few modifications
	\param l1 is a parameter in 3j symbol
	\param l2 is a parameter in 3j symbol
	\param l3 is a parameter in 3j symbol
	\param m1 is a parameter in 3j symbol
	\param m2 is the smallest allowable m2 in 3j symbol
	\param m3 is the largest allowable m3 in 3j symbol
	\param thrcof is the set of 3j coefficients generated by evaluating the
					 3j symbol for all allowed values of m2.  thrcof(i)
					 will contain g(m2min+i-1), i=1,2,...,m2max-m2min+1
	\param ndim is the declared length of thrcof in calling program.
	\param errflag is the error flag
					 errflag=0 No errors.
					 errflag=1 Either l1.LT.ABS(M1) or l1+ABS(M1) non-integer.
					 errflag=2 ABS(l1-l2).LE.l3.LE.l1+l2 not satisfied.
					 errflag=3 l1+l2+l3 not an integer.
					 errflag=4 m2max-m2min not an integer.
					 errflag=5 m2max less than m2min.
					 errflag=6 ndim less than m2max-m2min+1.
	*/
	void w3j(double l1, double l2, double l3, double m1, double &m2min,
		double &m2max, double *thrcof, int ndim, int &errflag)
	{
	  const double zero = 0.0, eps = 0.01, one = 1.0, two = 2.0;

	  int nfin, nlim, i, n, index, lstep, nfinp1, nfinp2, nfinp3, nstep2;
	  double oldfac, dv, newfac, sumbac = 0.0, thresh, a1s, sumfor, sumuni,
			 sum1, sum2, x, y, m2, m3, x1, x2, x3, y1, y2, y3, cnorm,
			 ratio, a1, c1, c2, c1old = 0.0, sign1, sign2;

	  //Parameter adjustments
	  --thrcof;

	  errflag = 0;

	  //"huge" is the square root of one twentieth of the largest floating
	  //point number, approximately.
	  double huge   = sqrt(std::numeric_limits<double>::max() / 20.0),
			 srhuge = sqrt(huge),
			 tiny   = one / huge,
			 srtiny = one / srhuge;

	  // lmatch = zero

	  //  Check error conditions 1, 2, and 3.
	  if (l1 - fabs(m1) + eps < zero
		  || fmod(l1 + fabs(m1) + eps, one) >= eps + eps) {
		errflag = 1;
		std::cerr << "w3j: "
		 << " l1-abs(m1) less than zero or l1+abs(m1) not integer.";
		return;
	  } else if (l1+l2-l3 < -eps || l1-l2+l3 < -eps || -(l1) + l2+l3 < -eps) {
		errflag = 2;
		std::cerr << "w3j: l1, l2, l3 do not satisfy triangular condition.";
		return;
	  } else if (fmod(l1 + l2 + l3 + eps, one) >= eps + eps) {
		  errflag = 3;
		  std::cerr << "w3j: l1+l2+l3 not integer.";
		  return;
	  }

	  //limits for m2
	  m2min = (-l2 > (-l3-m1)) ? -l2 : (-l3-m1);
	  m2max = (l2 < (l3-m1)) ? l2 : (l3-m1);

	  //Check error condition 4.
	  if (fmod(m2max - m2min + eps, one) >= eps + eps) {
		errflag = 4;
		std::cerr << "w3j: m2max-m2min not integer.";
		return;
	  }
	  if (m2min < m2max - eps) goto L20;
	  if (m2min < m2max + eps) goto L10;

	  //Check error condition 5.
	  errflag = 5;
	  std::cerr << "w3j: m2min greater than m2max.";
	  return;

	  //This is reached in case that m2 and m3 can take only one value.
	L10:
	  //mscale = 0
	  thrcof[1] = (((int(fabs(l2-l3-m1)+eps))&1) ? -one : one) /
		sqrt(l1+l2+l3+one);
	  return;

	  //This is reached in case that M1 and M2 take more than one value.
	L20:
	  //mscale = 0
	  nfin = int(m2max - m2min + one + eps);
	  if (ndim - nfin >= 0) goto L23;

	  //Check error condition 6.

	  errflag = 6;
	  std::cerr << "w3j: "
		   << "Dimension of result array for 3j coefficients too small.";
	  return;

	  //Start of forward recursion from m2 = m2min

	L23:
	  m2 = m2min;
	  thrcof[1] = srtiny;
	  newfac = 0.0;
	  c1 = 0.0;
	  sum1 = tiny;

	  lstep = 1;
	L30:
	  ++lstep;
	  m2 += one;
	  m3 = -m1 - m2;

	  oldfac = newfac;
	  a1 = (l2 - m2 + one) * (l2 + m2) * (l3 + m3 + one) * (l3 - m3);
	  newfac = sqrt(a1);

	  dv = (l1+l2+l3+one) * (l2+l3-l1) - (l2-m2+one) * (l3+m3+one)
									   - (l2+m2-one) * (l3-m3-one);

	  if (lstep - 2 > 0) c1old = fabs(c1);

	// L32:
	  c1 = -dv / newfac;

	  if (lstep > 2) goto L60;

	  //If m2 = m2min + 1, the third term in the recursion equation vanishes,
	  //hence

	  x = srtiny * c1;
	  thrcof[2] = x;
	  sum1 += tiny * c1 * c1;
	  if (lstep == nfin) goto L220;
	  goto L30;

	L60:
	  c2 = -oldfac / newfac;

	  //Recursion to the next 3j coefficient
	  x = c1 * thrcof[lstep-1] + c2 * thrcof[lstep-2];
	  thrcof[lstep] = x;
	  sumfor = sum1;
	  sum1 += x * x;
	  if (lstep == nfin) goto L100;

	  //See if last unnormalized 3j coefficient exceeds srhuge

	  if (fabs(x) < srhuge) goto L80;

	  //This is reached if last 3j coefficient larger than srhuge,
	  //so that the recursion series thrcof(1), ... , thrcof(lstep)
	  //has to be rescaled to prevent overflow

	  //mscale = mscale + 1
	  for (i = 1; i <= lstep; ++i) {
		if (fabs(thrcof[i]) < srtiny) thrcof[i] = zero;
		thrcof[i] /= srhuge;
	  }
	  sum1 /= huge;
	  sumfor /= huge;
	  x /= srhuge;

	  //As long as abs(c1) is decreasing, the recursion proceeds towards
	  //increasing 3j values and, hence, is numerically stable.  Once
	  //an increase of abs(c1) is detected, the recursion direction is
	  //reversed.

	L80:
	  if (c1old - fabs(c1) > 0.0) goto L30;

	  //Keep three 3j coefficients around mmatch for comparison later
	  //with backward recursion values.

	L100:
	  //mmatch = m2 - 1
	  nstep2 = nfin - lstep + 3;
	  x1 = x;
	  x2 = thrcof[lstep-1];
	  x3 = thrcof[lstep-2];

	  //Starting backward recursion from m2max taking nstep2 steps, so
	  //that forwards and backwards recursion overlap at the three points
	  //m2 = mmatch+1, mmatch, mmatch-1.

	  nfinp1 = nfin + 1;
	  nfinp2 = nfin + 2;
	  nfinp3 = nfin + 3;
	  thrcof[nfin] = srtiny;
	  sum2 = tiny;

	  m2 = m2max + two;
	  lstep = 1;
	L110:
	  ++lstep;
	  m2 -= one;
	  m3 = -m1 - m2;
	  oldfac = newfac;
	  a1s = (l2-m2+two) * (l2+m2-one) * (l3+m3+two) * (l3-m3-one);
	  newfac = sqrt(a1s);
	  dv = (l1+l2+l3+one) * (l2+l3-l1) - (l2-m2+one) * (l3+m3+one)
									   - (l2+m2-one) * (l3-m3-one);
	  c1 = -dv / newfac;
	  if (lstep > 2) goto L120;

	  //if m2 = m2max + 1 the third term in the recursion equation vanishes

	  y = srtiny * c1;
	  thrcof[nfin - 1] = y;
	  if (lstep == nstep2) goto L200;
	  sumbac = sum2;
	  sum2 += y * y;
	  goto L110;

	L120:
	  c2 = -oldfac / newfac;

	  //Recursion to the next 3j coefficient

	  y = c1 * thrcof[nfinp2 - lstep] + c2 * thrcof[nfinp3 - lstep];

	  if (lstep == nstep2) goto L200;

	  thrcof[nfinp1 - lstep] = y;
	  sumbac = sum2;
	  sum2 += y * y;

	  //See if last 3j coefficient exceeds SRHUGE

	  if (fabs(y) < srhuge) goto L110;

	  //This is reached if last 3j coefficient larger than srhuge,
	  //so that the recursion series thrcof(nfin), ... , thrcof(nfin-lstep+1)
	  //has to be rescaled to prevent overflow.

	  //mscale = mscale + 1
	  for (i = 1; i <= lstep; ++i) {
		index = nfin - i + 1;
		if (fabs(thrcof[index]) < srtiny) thrcof[index] = zero;
		thrcof[index] /= srhuge;
	  }
	  sum2 /= huge;
	  sumbac /= huge;

	  goto L110;

	  //The forward recursion 3j coefficients x1, x2, x3 are to be matched
	  //with the corresponding backward recursion values y1, y2, y3.

	L200:
	  y3 = y;
	  y2 = thrcof[nfinp2-lstep];
	  y1 = thrcof[nfinp3-lstep];

	  //Determine now ratio such that yi = ratio * xi  (i=1,2,3) holds
	  //with minimal error.

	  ratio = (x1*y1 + x2*y2 + x3*y3) / (x1*x1 + x2*x2 + x3*x3);
	  nlim = nfin - nstep2 + 1;

	  if (fabs(ratio) < one) goto L211;
	  for (n = 1; n <= nlim; ++n)
		thrcof[n] = ratio * thrcof[n];
	  sumuni = ratio * ratio * sumfor + sumbac;
	  goto L230;

	L211:
	  ++nlim;
	  ratio = one / ratio;
	  for (n = nlim; n <= nfin; ++n)
		thrcof[n] = ratio * thrcof[n];
	  sumuni = sumfor + ratio * ratio * sumbac;
	  goto L230;

	L220:
	  sumuni = sum1;

	  //Normalize 3j coefficients

	L230:
	  cnorm = one / sqrt((l1+l1+one) * sumuni);

	  //Sign convention for last 3j coefficient determines overall phase
	  sign1 =
	(thrcof[nfin] < 0) ? ((one < 0) ? one : -one) : ((one > 0) ? one : -one);
	  sign2 = ((int(fabs(l2-l3-m1)+eps))&1) ? -one : one;
	  if (sign1 * sign2 <= 0.0) goto L235;
	  else goto L236;

	L235:
	  cnorm = -cnorm;

	L236:
	  if (fabs(cnorm) < one) goto L250;

	  for (n = 1; n <= nfin; ++n)
		thrcof[n] = cnorm * thrcof[n];
	  return;

	L250:
	  thresh = tiny / fabs(cnorm);
	  for (n = 1; n <= nfin; ++n) {
		if (fabs(thrcof[n]) < thresh) thrcof[n] = zero;
		thrcof[n] = cnorm * thrcof[n];
	  }
	}

#endif

}

