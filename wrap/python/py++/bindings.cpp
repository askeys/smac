/**
SMAC -- Shape Matching Analysis Code
(SMAC) Open Source Software License Copyright 2012 The Regents of the 
University of Michigan All rights reserved.

SMAC may contain modifications ("Contributions") provided, and to which
copyright is held, by various Contributors who have granted The Regents of the
University of Michigan the right to modify and/or distribute such Contributions.

You may redistribute, use, and create derivate works of SMAC, in source
and binary forms, provided you abide by the following conditions:

* Redistributions of source code must retain the above copyright notice, this
list of conditions, and the following disclaimer both in the code and
prominently in any materials provided with the distribution.

* Redistributions in binary form must reproduce the above copyright notice, this
list of conditions, and the following disclaimer in the documentation and/or
other materials provided with the distribution.

* Apart from the above required attributions, neither the name of the copyright
holder nor the names of LibTPS's contributors may be used to endorse or
promote products derived from this software without specific prior written
permission.

Disclaimer

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND/OR ANY
WARRANTIES THAT THIS SOFTWARE IS FREE OF INFRINGEMENT ARE DISCLAIMED.

IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/// This file has been generated by Py++.

#include "boost/python.hpp"

#include "boost/python/suite/indexing/vector_indexing_suite.hpp"

#include "boost/python/suite/indexing/map_indexing_suite.hpp"

#include "../../../src/smac.h"

namespace bp = boost::python;

struct Cell_wrapper : smac::Cell, bp::wrapper< smac::Cell > {

    Cell_wrapper(smac::Cell const & arg )
    : smac::Cell( arg )
      , bp::wrapper< smac::Cell >(){
        // copy constructor
        
    }

    Cell_wrapper( )
    : smac::Cell( )
      , bp::wrapper< smac::Cell >(){
        // null constructor
    
    }

    virtual void clear(  ) {
        if( bp::override func_clear = this->get_override( "clear" ) )
            func_clear(  );
        else
            this->smac::Cell::clear(  );
    }
    
    
    void default_clear(  ) {
        smac::Cell::clear( );
    }

    virtual void clearContents(  ) {
        if( bp::override func_clearContents = this->get_override( "clearContents" ) )
            func_clearContents(  );
        else
            this->smac::Cell::clearContents(  );
    }
    
    
    void default_clearContents(  ) {
        smac::Cell::clearContents( );
    }

    virtual void insert( int arg0 ) {
        if( bp::override func_insert = this->get_override( "insert" ) )
            func_insert( arg0 );
        else
            this->smac::Cell::insert( arg0 );
    }
    
    
    void default_insert( int arg0 ) {
        smac::Cell::insert( arg0 );
    }

    virtual void remove( int arg0 ) {
        if( bp::override func_remove = this->get_override( "remove" ) )
            func_remove( arg0 );
        else
            this->smac::Cell::remove( arg0 );
    }
    
    
    void default_remove( int arg0 ) {
        smac::Cell::remove( arg0 );
    }

};

struct CellList_wrapper : smac::CellList, bp::wrapper< smac::CellList > {

    CellList_wrapper(smac::CellList const & arg )
    : smac::CellList( arg )
      , bp::wrapper< smac::CellList >(){
        // copy constructor
        
    }

    CellList_wrapper( )
    : smac::CellList( )
      , bp::wrapper< smac::CellList >(){
        // null constructor
    
    }

    virtual void clearContents(  ) {
        if( bp::override func_clearContents = this->get_override( "clearContents" ) )
            func_clearContents(  );
        else
            this->smac::CellList::clearContents(  );
    }
    
    
    void default_clearContents(  ) {
        smac::CellList::clearContents( );
    }

    virtual void divideBoxIntoCells(  ){
        if( bp::override func_divideBoxIntoCells = this->get_override( "divideBoxIntoCells" ) )
            func_divideBoxIntoCells(  );
        else
            this->smac::CellList::divideBoxIntoCells(  );
    }

    virtual void rebuild(  ){
        if( bp::override func_rebuild = this->get_override( "rebuild" ) )
            func_rebuild(  );
        else
            this->smac::CellList::rebuild(  );
    }

};

struct lmptraj_info_wrapper : smac::lmptraj_info, bp::wrapper< smac::lmptraj_info > {

    lmptraj_info_wrapper(smac::lmptraj_info const & arg )
    : smac::lmptraj_info( arg )
      , bp::wrapper< smac::lmptraj_info >(){
        // copy constructor
        
    }

    lmptraj_info_wrapper( )
    : smac::lmptraj_info( )
      , bp::wrapper< smac::lmptraj_info >(){
        // null constructor
    
    }

    static ::std::istream * get_instream(smac::lmptraj_info const & inst ){
        return inst.instream;
    }
    
    static void set_instream( smac::lmptraj_info & inst, ::std::istream * new_value ){ 
        inst.instream = new_value;
    }

};

struct registersymmetryaxis_info_wrapper : smac::registersymmetryaxis_info, bp::wrapper< smac::registersymmetryaxis_info > {

    registersymmetryaxis_info_wrapper(smac::registersymmetryaxis_info const & arg )
    : smac::registersymmetryaxis_info( arg )
      , bp::wrapper< smac::registersymmetryaxis_info >(){
        // copy constructor
        
    }

    registersymmetryaxis_info_wrapper( )
    : smac::registersymmetryaxis_info( )
      , bp::wrapper< smac::registersymmetryaxis_info >(){
        // null constructor
    
    }

    static ::smac::fourierdesc2d_info * get_fourierargs(smac::registersymmetryaxis_info const & inst ){
        return inst.fourierargs;
    }
    
    static void set_fourierargs( smac::registersymmetryaxis_info & inst, ::smac::fourierdesc2d_info * new_value ){ 
        inst.fourierargs = new_value;
    }

};

struct xyz_info_wrapper : smac::xyz_info, bp::wrapper< smac::xyz_info > {

    xyz_info_wrapper(smac::xyz_info const & arg )
    : smac::xyz_info( arg )
      , bp::wrapper< smac::xyz_info >(){
        // copy constructor
        
    }

    xyz_info_wrapper( )
    : smac::xyz_info( )
      , bp::wrapper< smac::xyz_info >(){
        // null constructor
    
    }

    static ::std::istream * get_instream(smac::xyz_info const & inst ){
        return inst.instream;
    }
    
    static void set_instream( smac::xyz_info & inst, ::std::istream * new_value ){ 
        inst.instream = new_value;
    }

    static ::std::ostream * get_outstream(smac::xyz_info const & inst ){
        return inst.outstream;
    }
    
    static void set_outstream( smac::xyz_info & inst, ::std::ostream * new_value ){ 
        inst.outstream = new_value;
    }

};

BOOST_PYTHON_MODULE(libsmac){
/*
	{ //::std::vector< unsigned int >
        typedef bp::class_< std::vector< unsigned int > > vector_less__unsigned_int__greater__exposer_t;
        vector_less__unsigned_int__greater__exposer_t vector_less__unsigned_int__greater__exposer = vector_less__unsigned_int__greater__exposer_t( "vector_less__unsigned_int__greater_" );
        bp::scope vector_less__unsigned_int__greater__scope( vector_less__unsigned_int__greater__exposer );
        vector_less__unsigned_int__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< unsigned int >, true >() );
    }

 * Wrapper of the IDL is wrong!!!
    { //::std::vector< std::vector< std::complex<double> > >
        typedef bp::class_< std::vector< std::vector< std::complex<double> > > > shpdesclist_t_exposer_t;
        shpdesclist_t_exposer_t shpdesclist_t_exposer = shpdesclist_t_exposer_t( "shpdesclist_t" );
        bp::scope shpdesclist_t_scope( shpdesclist_t_exposer );
        shpdesclist_t_exposer.def( bp::vector_indexing_suite< ::std::vector< std::vector< std::complex<double> > > >() );
    }


 * The wrapper of the IDL is wrong!!!
    { //::std::vector< std::vector< int > >
        typedef bp::class_< std::vector< std::vector< int > > > clstrlist_t_exposer_t;
        clstrlist_t_exposer_t clstrlist_t_exposer = clstrlist_t_exposer_t( "clstrlist_t" );
        bp::scope clstrlist_t_scope( clstrlist_t_exposer );
        //WARNING: the next line of code will not compile, because "::std::vector<int, std::allocator<int> >" does not have operator== !
        clstrlist_t_exposer.def( bp::vector_indexing_suite< ::std::vector< std::vector< int > > >() );
    }


 * The wrapper of the IDL is wrong!!!
    { //::std::vector< std::vector< double > >
        typedef bp::class_< std::vector< std::vector< double > > > coordlist_t_exposer_t;
        coordlist_t_exposer_t coordlist_t_exposer = coordlist_t_exposer_t( "coordlist_t" );
        bp::scope coordlist_t_scope( coordlist_t_exposer );
        //WARNING: the next line of code will not compile, because "::std::vector<double, std::allocator<double> >" does not have operator== !
        coordlist_t_exposer.def( bp::vector_indexing_suite< ::std::vector< std::vector< double > > >() );
    }

    { //::std::vector< std::string >
        typedef bp::class_< std::vector< std::string > > vector_less__std_scope_string__greater__exposer_t;
        vector_less__std_scope_string__greater__exposer_t vector_less__std_scope_string__greater__exposer = vector_less__std_scope_string__greater__exposer_t( "vector_less__std_scope_string__greater_" );
        bp::scope vector_less__std_scope_string__greater__scope( vector_less__std_scope_string__greater__exposer );
        vector_less__std_scope_string__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< std::string >, true >() );
    }

    { //scope begin
        typedef bp::class_< std::vector< std::complex<double> > > vector_less__std_scope_complex_less_double_greater___greater__exposer_t;
        vector_less__std_scope_complex_less_double_greater___greater__exposer_t vector_less__std_scope_complex_less_double_greater___greater__exposer = vector_less__std_scope_complex_less_double_greater___greater__exposer_t("vector_less__std_scope_complex_less_double_greater___greater_");
        bp::scope vector_less__std_scope_complex_less_double_greater___greater__scope( vector_less__std_scope_complex_less_double_greater___greater__exposer );
        //WARNING: the next line of code will not compile, because "::std::complex<double>" does not have operator== !
        vector_less__std_scope_complex_less_double_greater___greater__exposer.def( bp::vector_indexing_suite< ::std::vector< std::complex<double> > >() );
    } //scope end

    { //::std::vector< int >
        typedef bp::class_< std::vector< int > > vector_less__int__greater__exposer_t;
        vector_less__int__greater__exposer_t vector_less__int__greater__exposer = vector_less__int__greater__exposer_t( "vector_less__int__greater_" );
        bp::scope vector_less__int__greater__scope( vector_less__int__greater__exposer );
        vector_less__int__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< int >, true >() );
    }

    { //::std::vector< double >
        typedef bp::class_< std::vector< double > > vector_less__double__greater__exposer_t;
        vector_less__double__greater__exposer_t vector_less__double__greater__exposer = vector_less__double__greater__exposer_t( "vector_less__double__greater_" );
        bp::scope vector_less__double__greater__scope( vector_less__double__greater__exposer );
        vector_less__double__greater__exposer.def( bp::vector_indexing_suite< ::std::vector< double >, true >() );
    }

    { //::std::vector< bool >
        typedef bp::class_< std::vector< bool > > bool_array_t_exposer_t;
        bool_array_t_exposer_t bool_array_t_exposer = bool_array_t_exposer_t( "bool_array_t" );
        bp::scope bool_array_t_scope( bool_array_t_exposer );
        bool_array_t_exposer.def( bp::vector_indexing_suite< ::std::vector< bool >, true >() );
    }

    { //::std::map< std::string, int >
        typedef bp::class_< std::map< std::string, int > > map_less__std_scope_string_comma__int__greater__exposer_t;
        map_less__std_scope_string_comma__int__greater__exposer_t map_less__std_scope_string_comma__int__greater__exposer = map_less__std_scope_string_comma__int__greater__exposer_t( "map_less__std_scope_string_comma__int__greater_" );
        bp::scope map_less__std_scope_string_comma__int__greater__scope( map_less__std_scope_string_comma__int__greater__exposer );
        map_less__std_scope_string_comma__int__greater__exposer.def( bp::map_indexing_suite< ::std::map< std::string, int >, true >() );
    }

    bp::class_< std::map< double, double > >("map_less__double_comma__double__greater_")    
        .def( bp::map_indexing_suite< ::std::map< double, double >, true >() );
*/
    bp::scope().attr("INVARIANT_NONE") = (int)smac::INVARIANT_NONE;
    bp::scope().attr("INVARIANT_Q") = (int)smac::INVARIANT_Q;
    bp::scope().attr("INVARIANT_W") = (int)smac::INVARIANT_W;

    bp::scope().attr("COMPLEX") = (int)smac::COMPLEX;
    bp::scope().attr("REAL") = (int)smac::REAL;
    bp::scope().attr("IMAG") = (int)smac::IMAG;

    bp::scope().attr("RADIALNORMCENTROID") = (int)smac::RADIALNORMCENTROID;
    bp::scope().attr("RADIALEXCLUDECENTROID") = (int)smac::RADIALEXCLUDECENTROID;
    bp::scope().attr("RADIALNORM") = (int)smac::RADIALNORM;
    bp::scope().attr("RADIALEXCLUDE") = (int)smac::RADIALEXCLUDE;
    bp::scope().attr("NONE") = (int)smac::NONE;

    bp::scope().attr("CENTROID") = (int)smac::CENTROID;
    bp::scope().attr("CENTER_PARTICLE") = (int)smac::CENTER_PARTICLE;
    bp::scope().attr("SKIP_TRANSLATE") = (int)smac::SKIP_TRANSLATE;

    bp::scope().attr("MATCHSTD") = (int)smac::MATCHSTD;
    bp::scope().attr("MATCHNEGATE") = (int)smac::MATCHNEGATE;
    bp::scope().attr("MATCHABS") = (int)smac::MATCHABS;

    bp::scope().attr("RMS") = (int)smac::RMS;
    bp::scope().attr("RSQ") = (int)smac::RSQ;
    bp::scope().attr("DOT") = (int)smac::DOT;

    bp::enum_< smac::ICPTrialType>("ICPTrialType")
        .value("LINEAR", smac::LINEAR)
        .value("RANDOM", smac::RANDOM)
        .export_values()
        ;

    bp::class_< Cell_wrapper >( "Cell", bp::init< >() )    
        .def( 
            "addNeighbor"
            , (void ( ::smac::Cell::* )( int ) )( &::smac::Cell::addNeighbor )
            , ( bp::arg("arg0") ) )    
        .def( 
            "clear"
            , (void ( ::smac::Cell::* )(  ) )(&::smac::Cell::clear)
            , (void ( Cell_wrapper::* )(  ) )(&Cell_wrapper::default_clear) )    
        .def( 
            "clearContents"
            , (void ( ::smac::Cell::* )(  ) )(&::smac::Cell::clearContents)
            , (void ( Cell_wrapper::* )(  ) )(&Cell_wrapper::default_clearContents) )    
        .def( 
            "getContents"
            , (::std::vector< int > ( ::smac::Cell::* )(  ) )( &::smac::Cell::getContents ) )    
        .def( 
            "getNeighbors"
            , (::std::vector< int > ( ::smac::Cell::* )(  ) )( &::smac::Cell::getNeighbors ) )    
        .def( 
            "getNumberOfNeighbors"
            , (int ( ::smac::Cell::* )(  ) const)( &::smac::Cell::getNumberOfNeighbors ) )    
        .def( 
            "getNumberOfObjects"
            , (int ( ::smac::Cell::* )(  ) )( &::smac::Cell::getNumberOfObjects ) )    
        .def( 
            "insert"
            , (void ( ::smac::Cell::* )( int ) )(&::smac::Cell::insert)
            , (void ( Cell_wrapper::* )( int ) )(&Cell_wrapper::default_insert)
            , ( bp::arg("arg0") ) )    
        .def( 
            "remove"
            , (void ( ::smac::Cell::* )( int ) )(&::smac::Cell::remove)
            , (void ( Cell_wrapper::* )( int ) )(&Cell_wrapper::default_remove)
            , ( bp::arg("arg0") ) );

    { //::smac::CellList
        typedef bp::class_< CellList_wrapper > CellList_exposer_t;
        CellList_exposer_t CellList_exposer = CellList_exposer_t( "CellList", bp::init< >() );
        bp::scope CellList_scope( CellList_exposer );
        bp::scope().attr("FULL") = (int)smac::CellList::FULL;
        bp::scope().attr("HALF") = (int)smac::CellList::HALF;
        { //::smac::CellList::clear
        
            typedef void ( ::smac::CellList::*clear_function_type )(  ) ;
            
            CellList_exposer.def( 
                "clear"
                , clear_function_type( &::smac::CellList::clear ) );
        
        }
        { //::smac::CellList::clearContents
        
            typedef void ( ::smac::CellList::*clearContents_function_type )(  ) ;
            typedef void ( CellList_wrapper::*default_clearContents_function_type )(  ) ;
            
            CellList_exposer.def( 
                "clearContents"
                , clearContents_function_type(&::smac::CellList::clearContents)
                , default_clearContents_function_type(&CellList_wrapper::default_clearContents) );
        
        }
        { //::smac::CellList::divideBoxIntoCells
        
            typedef void ( CellList_wrapper::*divideBoxIntoCells_function_type )(  ) ;
            
            CellList_exposer.def( 
                "divideBoxIntoCells"
                , divideBoxIntoCells_function_type( &CellList_wrapper::divideBoxIntoCells ) );
        
        }
        { //::smac::CellList::end
        
            typedef bool ( ::smac::CellList::*end_function_type )(  ) const;
            
            CellList_exposer.def( 
                "end"
                , end_function_type( &::smac::CellList::end ) );
        
        }
        { //::smac::CellList::fail
        
            typedef bool ( ::smac::CellList::*fail_function_type )(  ) const;
            
            CellList_exposer.def( 
                "fail"
                , fail_function_type( &::smac::CellList::fail ) );
        
        }
        { //::smac::CellList::getCell
        
            typedef ::smac::Cell ( ::smac::CellList::*getCell_function_type )( int ) ;
            
            CellList_exposer.def( 
                "getCell"
                , getCell_function_type( &::smac::CellList::getCell )
                , ( bp::arg("arg0") ) );
        
        }
        { //::smac::CellList::getCellContaining
        
            typedef int ( ::smac::CellList::*getCellContaining_function_type )( ::smac::coord_t & ) const;
            
            CellList_exposer.def( 
                "getCellContaining"
                , getCellContaining_function_type( &::smac::CellList::getCellContaining )
                , ( bp::arg("arg0") ) );
        
        }
        { //::smac::CellList::getCellContaining
        
            typedef int ( ::smac::CellList::*getCellContaining_function_type )( int ) ;
            
            CellList_exposer.def( 
                "getCellContaining"
                , getCellContaining_function_type( &::smac::CellList::getCellContaining )
                , ( bp::arg("arg0") ) );
        
        }
        { //::smac::CellList::getNeighborsOf
        
            typedef void ( ::smac::CellList::*getNeighborsOf_function_type )( int,::std::vector< int > & ) ;
            
            CellList_exposer.def( 
                "getNeighborsOf"
                , getNeighborsOf_function_type( &::smac::CellList::getNeighborsOf )
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        
        }
        { //::smac::CellList::getNumberOfCells
        
            typedef int ( ::smac::CellList::*getNumberOfCells_function_type )(  ) const;
            
            CellList_exposer.def( 
                "getNumberOfCells"
                , getNumberOfCells_function_type( &::smac::CellList::getNumberOfCells ) );
        
        }
        { //::smac::CellList::getPositionOfCell
        
            typedef ::smac::coord_t ( ::smac::CellList::*getPositionOfCell_function_type )( int ) ;
            
            CellList_exposer.def( 
                "getPositionOfCell"
                , getPositionOfCell_function_type( &::smac::CellList::getPositionOfCell )
                , ( bp::arg("arg0") ) );
        
        }
        { //::smac::CellList::good
        
            typedef bool ( ::smac::CellList::*good_function_type )(  ) const;
            
            CellList_exposer.def( 
                "good"
                , good_function_type( &::smac::CellList::good ) );
        
        }
        { //::smac::CellList::insert
        
            typedef void ( ::smac::CellList::*insert_function_type )( int,::smac::coord_t & ) ;
            
            CellList_exposer.def( 
                "insert"
                , insert_function_type( &::smac::CellList::insert )
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        
        }
        { //::smac::CellList::nextPair
        
            typedef ::std::pair< int, int > ( ::smac::CellList::*nextPair_function_type )(  ) ;
            
            CellList_exposer.def( 
                "nextPair"
                , nextPair_function_type( &::smac::CellList::nextPair ) );
        
        }
        { //::smac::CellList::placeInCorrectCell
        
            typedef void ( ::smac::CellList::*placeInCorrectCell_function_type )( int,::smac::coord_t & ) ;
            
            CellList_exposer.def( 
                "placeInCorrectCell"
                , placeInCorrectCell_function_type( &::smac::CellList::placeInCorrectCell )
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        
        }
        { //::smac::CellList::rebuild
        
            typedef void ( CellList_wrapper::*rebuild_function_type )(  ) ;
            
            CellList_exposer.def( 
                "rebuild"
                , rebuild_function_type( &CellList_wrapper::rebuild ) );
        
        }
        { //::smac::CellList::remove
        
            typedef void ( ::smac::CellList::*remove_function_type )( int ) ;
            
            CellList_exposer.def( 
                "remove"
                , remove_function_type( &::smac::CellList::remove )
                , ( bp::arg("arg0") ) );
        
        }
        { //::smac::CellList::resetIterator
        
            typedef void ( ::smac::CellList::*resetIterator_function_type )(  ) ;
            
            CellList_exposer.def( 
                "resetIterator"
                , resetIterator_function_type( &::smac::CellList::resetIterator ) );
        
        }
        { //::smac::CellList::setBox
        
            typedef void ( ::smac::CellList::*setBox_function_type )( ::smac::coord_t & ) ;
            
            CellList_exposer.def( 
                "setBox"
                , setBox_function_type( &::smac::CellList::setBox )
                , ( bp::arg("arg0") ) );
        
        }
        { //::smac::CellList::setBox
        
            typedef void ( ::smac::CellList::*setBox_function_type )( ::smac::coord_t &,::smac::coord_t & ) ;
            
            CellList_exposer.def( 
                "setBox"
                , setBox_function_type( &::smac::CellList::setBox )
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        
        }
        { //::smac::CellList::setBox
        
            typedef void ( ::smac::CellList::*setBox_function_type )( ::smac::coord_t &,::smac::coord_t &,::std::vector< bool > & ) ;
            
            CellList_exposer.def( 
                "setBox"
                , setBox_function_type( &::smac::CellList::setBox )
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) );
        
        }
        { //::smac::CellList::setInteractionRange
        
            typedef void ( ::smac::CellList::*setInteractionRange_function_type )( double ) ;
            
            CellList_exposer.def( 
                "setInteractionRange"
                , setInteractionRange_function_type( &::smac::CellList::setInteractionRange )
                , ( bp::arg("arg0") ) );
        
        }
        { //::smac::CellList::setMinimumCellSize
        
            typedef void ( ::smac::CellList::*setMinimumCellSize_function_type )( double ) ;
            
            CellList_exposer.def( 
                "setMinimumCellSize"
                , setMinimumCellSize_function_type( &::smac::CellList::setMinimumCellSize )
                , ( bp::arg("arg0") ) );
        
        }
        { //::smac::CellList::setNeighborStyle
        
            typedef void ( ::smac::CellList::*setNeighborStyle_function_type )( int ) ;
            
            CellList_exposer.def( 
                "setNeighborStyle"
                , setNeighborStyle_function_type( &::smac::CellList::setNeighborStyle )
                , ( bp::arg("arg0") ) );
        
        }
    }

    // My interface declarations
    bp::class_< smac::coord_t>("coord_t", bp::init<>())
    	.def(bp::vector_indexing_suite<std::vector<double> >());
    bp::class_< smac::coordlist_t>("coordlist_t", bp::init<>())
    	.def(bp::vector_indexing_suite<std::vector<std::vector<double> > >());
    bp::class_< smac::component_t>("component_t", bp::init<>())
    	.def(bp::vector_indexing_suite<std::vector<std::complex<double> > >());
    bp::class_< smac::shpdesc_t>("shpdesc_t", bp::init<>())
    	.def(bp::vector_indexing_suite<std::vector<std::vector<std::complex<double> > > >());
    bp::class_< smac::shpdesclist_t>("shpdesclist_t", bp::init<>())
    	.def(bp::vector_indexing_suite<std::vector<std::vector<std::vector<std::complex<double > > > > >());
    bp::class_< smac::bool_array_t>("bool_array_t", bp::init<>())
    	.def(bp::vector_indexing_suite<std::vector<bool> >());
    bp::class_< smac::voxel_t>("voxel_t", bp::init<>())
    	.def(bp::vector_indexing_suite<std::vector<double> >());
    bp::class_< smac::clstr_t>("clstr_t", bp::init<>())
    	.def(bp::vector_indexing_suite<std::vector<int> >());
    bp::class_< smac::clstrlist_t>("clstrlist_t", bp::init<>())
        .def(bp::vector_indexing_suite<std::vector<std::vector<int> > >());
    bp::class_< smac::clstr_t>("clstr_t", bp::init<>())
        .def(bp::vector_indexing_suite<std::vector<int> >());
    bp::class_< smac::function1d_t>("function1d_t", bp::init<>())
    	.def(bp::map_indexing_suite<std::map<double, double> >());
    bp::class_< smac::weight_t>("weight_t", bp::init<>())
    	.def(bp::vector_indexing_suite<std::vector<double> >());

    // My interface declarations
    // AUTOMATIC after this point.
    bp::class_< smac::box_t >( "box_t", bp::init< >() )    
        .def_readwrite( "boxhi", &smac::box_t::boxhi )    
        .def_readwrite( "boxlo", &smac::box_t::boxlo )    
        .def_readwrite( "period", &smac::box_t::period )    
        .def_readwrite( "periodic", &smac::box_t::periodic );

    bp::class_< smac::clstrrulerange_info >( "clstrrulerange_info", bp::init< >() )    
        .def_readwrite( "box", &smac::clstrrulerange_info::box )    
        .def_readwrite( "dim", &smac::clstrrulerange_info::dim )    
        .def_readwrite( "rcutsq", &smac::clstrrulerange_info::rcutsq )    
        .def_readwrite( "x", &smac::clstrrulerange_info::x );

    bp::class_< smac::clstrrulerangetype_info >( "clstrrulerangetype_info", bp::init< >() )    
        .def_readwrite( "box", &smac::clstrrulerangetype_info::box )    
        .def_readwrite( "dim", &smac::clstrrulerangetype_info::dim )    
        .def_readwrite( "rcutsq", &smac::clstrrulerangetype_info::rcutsq )    
        .def_readwrite( "type", &smac::clstrrulerangetype_info::type )    
        .def_readwrite( "x", &smac::clstrrulerangetype_info::x );

    bp::class_< smac::clstrruleshell_info >( "clstrruleshell_info", bp::init< >() )    
        .def_readwrite( "box", &smac::clstrruleshell_info::box )    
        .def_readwrite( "dim", &smac::clstrruleshell_info::dim )    
        .def_readwrite( "rcutsqinner", &smac::clstrruleshell_info::rcutsqinner )    
        .def_readwrite( "rcutsqouter", &smac::clstrruleshell_info::rcutsqouter )    
        .def_readwrite( "x", &smac::clstrruleshell_info::x );

    bp::class_< smac::crystalanalysis_info >( "crystalanalysis_info", bp::init< >() )    
        .def_readwrite( "crystalbondcut", &smac::crystalanalysis_info::crystalbondcut )    
        .def_readwrite( "crystalparticlecut", &smac::crystalanalysis_info::crystalparticlecut )    
        .def_readwrite( "matchmode", &smac::crystalanalysis_info::matchmode )    
        .def_readwrite( "rangecluster", &smac::crystalanalysis_info::rangecluster )    
        .def_readwrite( "rangecompare", &smac::crystalanalysis_info::rangecompare )    
        .def_readwrite( "rangedescriptor", &smac::crystalanalysis_info::rangedescriptor )    
        .def_readwrite( "saveclusters", &smac::crystalanalysis_info::saveclusters )    
        .def_readwrite( "savedclusters", &smac::crystalanalysis_info::savedclusters )    
        .def_readwrite( "saveddescriptors", &smac::crystalanalysis_info::saveddescriptors )    
        .def_readwrite( "savedescriptors", &smac::crystalanalysis_info::savedescriptors );

    bp::class_< smac::extractsurface_info >( "extractsurface_info", bp::init< >() )    
        .def_readwrite( "dim", &smac::extractsurface_info::dim )    
        .def_readwrite( "minnbrs", &smac::extractsurface_info::minnbrs )    
        .def_readwrite( "range", &smac::extractsurface_info::range )    
        .def_readwrite( "rcentroidcut", &smac::extractsurface_info::rcentroidcut );

    bp::class_< smac::fourier_info >( "fourier_info", bp::init< >() )    
        .def_readwrite( "_costable", &smac::fourier_info::_costable )    
        .def_readwrite( "_frequency", &smac::fourier_info::_frequency )    
        .def_readwrite( "_sintable", &smac::fourier_info::_sintable )    
        .def_readwrite( "frequency", &smac::fourier_info::frequency )    
        .def_readwrite( "invariant", &smac::fourier_info::invariant )    
        .def_readwrite( "nsector", &smac::fourier_info::nsector )    
        .def_readwrite( "shells", &smac::fourier_info::shells )    
        .def_readwrite( "trigtablesize", &smac::fourier_info::trigtablesize );

    bp::class_< smac::lammpstrjfile >( "lammpstrjfile" )    
        .def_readwrite( "box", &smac::lammpstrjfile::box )    
        .def_readwrite( "n", &smac::lammpstrjfile::n )    
        .def_readwrite( "timestep", &smac::lammpstrjfile::timestep )    
        .def_readwrite( "type", &smac::lammpstrjfile::type )    
        .def_readwrite( "x", &smac::lammpstrjfile::x );

    bp::class_< lmptraj_info_wrapper >( "lmptraj_info", bp::init< >() )    
        .def_readwrite( "box", &smac::lmptraj_info::box )    
        .add_property( "instream"
                    , bp::make_function( (::std::istream * (*)( ::smac::lmptraj_info const & ))(&lmptraj_info_wrapper::get_instream), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::smac::lmptraj_info &,::std::istream * ))(&lmptraj_info_wrapper::set_instream), bp::with_custodian_and_ward_postcall< 1, 2 >() ) )    
        .def_readwrite( "type", &smac::lmptraj_info::type );

    bp::class_< smac::localorder_info >( "localorder_info", bp::init< >() )    
        .def_readwrite( "origin", &smac::localorder_info::origin );

    bp::class_< smac::matchvalue_t >( "matchvalue_t" )    
        .def_readwrite( "index", &smac::matchvalue_t::index )    
        .def_readwrite( "match", &smac::matchvalue_t::match );

    bp::class_< smac::rdf_info >( "rdf_info", bp::init< >() )    
        .def_readwrite( "binsize", &smac::rdf_info::binsize )    
        .def_readwrite( "rmax", &smac::rdf_info::rmax );

    bp::class_< smac::registericp_info >( "registericp_info", bp::init< >() )    
        .def_readwrite( "icptol", &smac::registericp_info::icptol )    
        .def_readwrite( "maxiter", &smac::registericp_info::maxiter )    
        .def_readwrite( "maxrotations", &smac::registericp_info::maxrotations )    
        .def_readwrite( "tol", &smac::registericp_info::tol )    
        .def_readwrite( "trialtype", &smac::registericp_info::trialtype );

    bp::class_< smac::registerpca_info >( "registerpca_info", bp::init< >() )    
        .def_readwrite( "mode", &smac::registerpca_info::mode );

    bp::class_< registersymmetryaxis_info_wrapper >( "registersymmetryaxis_info", bp::init< >() )    
        .def_readwrite( "beta", &smac::registersymmetryaxis_info::beta )    
        .def_readwrite( "dqmax", &smac::registersymmetryaxis_info::dqmax )    
        .def_readwrite( "eterminate", &smac::registersymmetryaxis_info::eterminate )    
        .add_property( "fourierargs"
                    , bp::make_function( (::smac::fourierdesc2d_info * (*)( ::smac::registersymmetryaxis_info const & ))(&registersymmetryaxis_info_wrapper::get_fourierargs), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::smac::registersymmetryaxis_info &,::smac::fourierdesc2d_info * ))(&registersymmetryaxis_info_wrapper::set_fourierargs), bp::with_custodian_and_ward_postcall< 1, 2 >() ) )    
        .def_readwrite( "niter", &smac::registersymmetryaxis_info::niter )    
        .def_readwrite( "nstartpoints", &smac::registersymmetryaxis_info::nstartpoints );

    bp::class_< smac::rmsassign_info >( "rmsassign_info", bp::init< >() )    
        .def_readwrite( "method", &smac::rmsassign_info::method )    
        .def_readwrite( "verbose", &smac::rmsassign_info::verbose );

    bp::class_< smac::rmsdesc_info >( "rmsdesc_info" );

    { //::smac::shapedata_t
        typedef bp::class_< smac::shapedata_t > shapedata_t_exposer_t;
        shapedata_t_exposer_t shapedata_t_exposer = shapedata_t_exposer_t( "shapedata_t", bp::init< >() );
        bp::scope shapedata_t_scope( shapedata_t_exposer );
        shapedata_t_exposer.def( bp::init< smac::coordlist_t &, smac::weight_t & >(( bp::arg("xi"), bp::arg("wi") )) );
        shapedata_t_exposer.def( bp::init< smac::coordlist_t & >(( bp::arg("xi") )) );
        bp::implicitly_convertible< smac::coordlist_t &, smac::shapedata_t >();
        shapedata_t_exposer.def_readwrite( "f", &smac::shapedata_t::f );
        shapedata_t_exposer.def_readwrite( "x", &smac::shapedata_t::x );
    }

    bp::class_< smac::shpdistA3_info >( "shpdistA3_info", bp::init< >() )    
        .def_readwrite( "box", &smac::shpdistA3_info::box )    
        .def_readwrite( "nbin", &smac::shpdistA3_info::nbin )    
        .def_readwrite( "rmax", &smac::shpdistA3_info::rmax )    
        .def_readwrite( "rmin", &smac::shpdistA3_info::rmin );

    bp::class_< smac::shpdistD2_info >( "shpdistD2_info", bp::init< >() )    
        .def_readwrite( "box", &smac::shpdistD2_info::box )    
        .def_readwrite( "nbin", &smac::shpdistD2_info::nbin )    
        .def_readwrite( "rmax", &smac::shpdistD2_info::rmax )    
        .def_readwrite( "rmin", &smac::shpdistD2_info::rmin );

    bp::class_< smac::shpdist_info >( "shpdist_info", bp::init< >() )    
        .def_readwrite( "comptype", &smac::shpdist_info::comptype )    
        .def_readwrite( "max", &smac::shpdist_info::max )    
        .def_readwrite( "min", &smac::shpdist_info::min )    
        .def_readwrite( "nbin", &smac::shpdist_info::nbin );

    bp::class_< smac::shphist_info >( "shphist_info", bp::init< >() )    
        .def_readwrite( "normalize", &smac::shphist_info::normalize )    
        .def_readwrite( "nsectors", &smac::shphist_info::nsectors )    
        .def_readwrite( "shells", &smac::shphist_info::shells );

    bp::class_< xyz_info_wrapper >( "xyz_info", bp::init< >() )    
        .def_readwrite( "box", &smac::xyz_info::box )    
        .add_property( "instream"
                    , bp::make_function( (::std::istream * (*)( ::smac::xyz_info const & ))(&xyz_info_wrapper::get_instream), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::smac::xyz_info &,::std::istream * ))(&xyz_info_wrapper::set_instream), bp::with_custodian_and_ward_postcall< 1, 2 >() ) )    
        .add_property( "outstream"
                    , bp::make_function( (::std::ostream * (*)( ::smac::xyz_info const & ))(&xyz_info_wrapper::get_outstream), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::smac::xyz_info &,::std::ostream * ))(&xyz_info_wrapper::set_outstream), bp::with_custodian_and_ward_postcall< 1, 2 >() ) )    
        .def_readwrite( "resevoir", &smac::xyz_info::resevoir )    
        .def_readwrite( "type", &smac::xyz_info::type )    
        .def_readwrite( "xres", &smac::xyz_info::xres );

    bp::class_< smac::xyzfile >( "xyzfile" )    
        .def_readwrite( "commentstr", &smac::xyzfile::commentstr )    
        .def_readwrite( "n", &smac::xyzfile::n )    
        .def_readwrite( "type", &smac::xyzfile::type )    
        .def_readwrite( "x", &smac::xyzfile::x );

    bp::class_< smac::zernike_info >( "zernike_info", bp::init< >() )    
        .def_readwrite( "_l", &smac::zernike_info::_l )    
        .def_readwrite( "_m", &smac::zernike_info::_m )    
        .def_readwrite( "_n", &smac::zernike_info::_n )    
        .def_readwrite( "invariant", &smac::zernike_info::invariant )    
        .def_readwrite( "moment", &smac::zernike_info::moment )    
        .def_readwrite( "normmethod", &smac::zernike_info::normmethod )    
        .def_readwrite( "rmax", &smac::zernike_info::rmax );

    { //::smac::add
    
        typedef void ( *add_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t & );
        
        bp::def( 
            "add"
            , add_function_type( &::smac::add )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::aggregate
    
        typedef void ( *aggregate_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t & );
        
        bp::def( 
            "aggregate"
            , aggregate_function_type( &::smac::aggregate )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::blur
    
        typedef void ( *blur_function_type )( ::smac::coordlist_t &,double,int );
        
        bp::def( 
            "blur"
            , blur_function_type( &::smac::blur )
            , ( bp::arg("x"), bp::arg("max"), bp::arg("npts") ) );
    
    }

    { //::smac::centroid
    
        typedef ::smac::coord_t ( *centroid_function_type )( ::smac::coordlist_t & );
        
        bp::def( 
            "centroid"
            , centroid_function_type( &::smac::centroid )
            , ( bp::arg("x") ) );
    
    }

    { //::smac::centroid
    
        typedef ::smac::coord_t ( *centroid_function_type )( ::smac::coordlist_t &,::smac::box_t & );
        
        bp::def( 
            "centroid"
            , centroid_function_type( &::smac::centroid )
            , ( bp::arg("x"), bp::arg("box") ) );
    
    }

    { //::smac::clstrrulerange
    
        typedef bool ( *clstrrulerange_function_type )( int,int,::smac::arg_t );
        
        bp::def( 
            "clstrrulerange"
            , clstrrulerange_function_type( &::smac::clstrrulerange )
            , ( bp::arg("i"), bp::arg("j"), bp::arg("arg2") ) );
    
    }

    { //::smac::clstrrulerangetype
    
        typedef bool ( *clstrrulerangetype_function_type )( int,int,::smac::arg_t );
        
        bp::def( 
            "clstrrulerangetype"
            , clstrrulerangetype_function_type( &::smac::clstrrulerangetype )
            , ( bp::arg("i"), bp::arg("j"), bp::arg("arg2") ) );
    
    }

    { //::smac::clstrruleshell
    
        typedef bool ( *clstrruleshell_function_type )( int,int,::smac::arg_t );
        
        bp::def( 
            "clstrruleshell"
            , clstrruleshell_function_type( &::smac::clstrruleshell )
            , ( bp::arg("i"), bp::arg("j"), bp::arg("arg2") ) );
    
    }

    { //::smac::coordtovoxel
    
        typedef void ( *coordtovoxel_function_type )( ::smac::coordlist_t &,::smac::CellList &,int );
        
        bp::def( 
            "coordtovoxel"
            , coordtovoxel_function_type( &::smac::coordtovoxel )
            , ( bp::arg("x"), bp::arg("voxels"), bp::arg("resolution")=(int)(10) ) );
    
    }

    { //::smac::crystalgrains
    
        typedef void ( *crystalgrains_function_type )( ::smac::coordlist_t &,::smac::box_t &,::smac::crystalanalysis_info &,::smac::clstrlist_t & );
        
        bp::def( 
            "crystalgrains"
            , crystalgrains_function_type( &::smac::crystalgrains )
            , ( bp::arg("x"), bp::arg("box"), bp::arg("arg2"), bp::arg("grains") ) );
    
    }

    { //::smac::deltype
    
        typedef void ( *deltype_function_type )( ::smac::coordlist_t &,::std::vector< std::string > &,::std::string );
        
        bp::def( 
            "deltype"
            , deltype_function_type( &::smac::deltype )
            , ( bp::arg("x"), bp::arg("types"), bp::arg("arg2") ) );
    
    }

    { //::smac::distance
    
        typedef double ( *distance_function_type )( ::smac::coord_t &,::smac::coord_t & );
        
        bp::def( 
            "distance"
            , distance_function_type( &::smac::distance )
            , ( bp::arg("x1"), bp::arg("x2") ) );
    
    }

    { //::smac::distance
    
        typedef double ( *distance_function_type )( ::smac::coord_t &,::smac::coord_t &,::smac::coord_t &,::smac::bool_array_t & );
        
        bp::def( 
            "distance"
            , distance_function_type( &::smac::distance )
            , ( bp::arg("x1"), bp::arg("x2"), bp::arg("period"), bp::arg("arg3") ) );
    
    }

    { //::smac::distancesq
    
        typedef double ( *distancesq_function_type )( ::smac::coord_t &,::smac::coord_t & );
        
        bp::def( 
            "distancesq"
            , distancesq_function_type( &::smac::distancesq )
            , ( bp::arg("x1"), bp::arg("x2") ) );
    
    }

    { //::smac::distancesq
    
        typedef double ( *distancesq_function_type )( ::smac::coord_t &,::smac::coord_t &,::smac::box_t & );
        
        bp::def( 
            "distancesq"
            , distancesq_function_type( &::smac::distancesq )
            , ( bp::arg("x1"), bp::arg("x2"), bp::arg("arg2") ) );
    
    }

    { //::smac::distancesq
    
        typedef double ( *distancesq_function_type )( ::smac::coord_t &,::smac::coord_t &,::smac::coord_t &,::smac::bool_array_t & );
        
        bp::def( 
            "distancesq"
            , distancesq_function_type( &::smac::distancesq )
            , ( bp::arg("x1"), bp::arg("x2"), bp::arg("arg2"), bp::arg("arg3") ) );
    
    }

    { //::smac::distancevec
    
        typedef ::smac::coord_t ( *distancevec_function_type )( ::smac::coord_t &,::smac::coord_t &,::smac::coord_t &,::smac::bool_array_t & );
        
        bp::def( 
            "distancevec"
            , distancevec_function_type( &::smac::distancevec )
            , ( bp::arg("x1"), bp::arg("x2"), bp::arg("period"), bp::arg("arg3") ) );
    
    }

    { //::smac::divide
    
        typedef void ( *divide_function_type )( ::smac::shpdesc_t &,double );
        
        bp::def( 
            "divide"
            , divide_function_type( &::smac::divide )
            , ( bp::arg("arg0"), bp::arg("d") ) );
    
    }

    { //::smac::divide
    
        typedef void ( *divide_function_type )( ::std::vector< double > &,double );
        
        bp::def( 
            "divide"
            , divide_function_type( &::smac::divide )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::extractsurface
    
        typedef void ( *extractsurface_function_type )( ::smac::shapedata_t &,::smac::box_t &,::std::vector< int > &,::smac::extractsurface_info & );
        
        bp::def( 
            "extractsurface"
            , extractsurface_function_type( &::smac::extractsurface )
            , ( bp::arg("s"), bp::arg("box"), bp::arg("surface"), bp::arg("info") ) );
    
    }

    { //::smac::fouriercoeff2d
    
        typedef void ( *fouriercoeff2d_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "fouriercoeff2d"
            , fouriercoeff2d_function_type( &::smac::fouriercoeff2d )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg") ) );
    
    }

    { //::smac::fouriercoeff3d
    
        typedef void ( *fouriercoeff3d_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "fouriercoeff3d"
            , fouriercoeff3d_function_type( &::smac::fouriercoeff3d )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg") ) );
    
    }

    { //::smac::fourierdesc2d
    
        typedef void ( *fourierdesc2d_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::fourier_info & );
        
        bp::def( 
            "fourierdesc2d"
            , fourierdesc2d_function_type( &::smac::fourierdesc2d )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg") ) );
    
    }

    { //::smac::fourierdesc3d
    
        typedef void ( *fourierdesc3d_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::fourier_info & );
        
        bp::def( 
            "fourierdesc3d"
            , fourierdesc3d_function_type( &::smac::fourierdesc3d )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg") ) );
    
    }

    { //::smac::inbox
    
        typedef bool ( *inbox_function_type )( ::smac::coord_t &,::smac::box_t );
        
        bp::def( 
            "inbox"
            , inbox_function_type( &::smac::inbox )
            , ( bp::arg("x"), bp::arg("box") ) );
    
    }

    { //::smac::inbox
    
        typedef bool ( *inbox_function_type )( ::smac::coordlist_t &,::smac::box_t );
        
        bp::def( 
            "inbox"
            , inbox_function_type( &::smac::inbox )
            , ( bp::arg("x"), bp::arg("box") ) );
    
    }

    { //::smac::insidebox
    
        typedef void ( *insidebox_function_type )( ::smac::coordlist_t &,::smac::box_t &,::std::vector< bool > & );
        
        bp::def( 
            "insidebox"
            , insidebox_function_type( &::smac::insidebox )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) );
    
    }

    { //::smac::insidesphere
    
        typedef void ( *insidesphere_function_type )( ::smac::coordlist_t &,::smac::coord_t &,double,::std::vector< bool > & );
        
        bp::def( 
            "insidesphere"
            , insidesphere_function_type( &::smac::insidesphere )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2"), bp::arg("arg3") ) );
    
    }

    { //::smac::invariantq
    
        typedef double ( *invariantq_function_type )( ::smac::shpdesc_t & );
        
        bp::def( 
            "invariantq"
            , invariantq_function_type( &::smac::invariantq )
            , ( bp::arg("arg0") ) );
    
    }

    { //::smac::invariantw
    
        typedef double ( *invariantw_function_type )( ::smac::shpdesc_t & );
        
        bp::def( 
            "invariantw"
            , invariantw_function_type( &::smac::invariantw )
            , ( bp::arg("arg0") ) );
    
    }

    { //::smac::load
    
        typedef void ( *load_function_type )( char const *,::smac::coordlist_t &,::smac::arg_t );
        
        bp::def( 
            "load"
            , load_function_type( &::smac::load )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2")=bp::object() ) );
    
    }

    { //::smac::loadlammpstrj
    
        typedef void ( *loadlammpstrj_function_type )( ::std::istream &,::smac::lammpstrjfile & );
        
        bp::def( 
            "loadlammpstrj"
            , loadlammpstrj_function_type( &::smac::loadlammpstrj )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::loadlammpstrj
    
        typedef void ( *loadlammpstrj_function_type )( char const *,::smac::lammpstrjfile & );
        
        bp::def( 
            "loadlammpstrj"
            , loadlammpstrj_function_type( &::smac::loadlammpstrj )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::loadlmptraj
    
        typedef void ( *loadlmptraj_function_type )( ::std::istream &,::smac::coordlist_t &,::smac::arg_t );
        
        bp::def( 
            "loadlmptraj"
            , loadlmptraj_function_type( &::smac::loadlmptraj )
            , ( bp::arg("is"), bp::arg("x"), bp::arg("arg") ) );
    
    }

    { //::smac::loadlmptraj
    
        typedef void ( *loadlmptraj_function_type )( char const *,::smac::coordlist_t &,::smac::arg_t );
        
        bp::def( 
            "loadlmptraj"
            , loadlmptraj_function_type( &::smac::loadlmptraj )
            , ( bp::arg("filename"), bp::arg("x"), bp::arg("arg2") ) );
    
    }

    { //::smac::loadxyz
    
        typedef void ( *loadxyz_function_type )( ::std::istream &,::smac::xyzfile & );
        
        bp::def( 
            "loadxyz"
            , loadxyz_function_type( &::smac::loadxyz )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::loadxyz
    
        typedef void ( *loadxyz_function_type )( char const *,::smac::xyzfile & );
        
        bp::def( 
            "loadxyz"
            , loadxyz_function_type( &::smac::loadxyz )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::loadxyz
    
        typedef void ( *loadxyz_function_type )( char const *,::smac::coordlist_t &,::smac::arg_t );
        
        bp::def( 
            "loadxyz"
            , loadxyz_function_type( &::smac::loadxyz )
            , ( bp::arg("filename"), bp::arg("x"), bp::arg("arg2")=bp::object() ) );
    
    }

    { //::smac::magnitude
    
        typedef double ( *magnitude_function_type )( ::smac::shpdesc_t & );
        
        bp::def( 
            "magnitude"
            , magnitude_function_type( &::smac::magnitude )
            , ( bp::arg("arg0") ) );
    
    }

    { //::smac::magnitudesq
    
        typedef double ( *magnitudesq_function_type )( ::smac::shpdesc_t & );
        
        bp::def( 
            "magnitudesq"
            , magnitudesq_function_type( &::smac::magnitudesq )
            , ( bp::arg("arg0") ) );
    
    }

    { //::smac::matchfunchisq
    
        typedef double ( *matchfunchisq_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,double,double );
        
        bp::def( 
            "matchfunchisq"
            , matchfunchisq_function_type( &::smac::matchfunchisq )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("min")=0.0, bp::arg("max")=1.0e+0 ) );
    
    }

    { //::smac::matchfunchisqrms
    
        typedef double ( *matchfunchisqrms_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,double,double );
        
        bp::def( 
            "matchfunchisqrms"
            , matchfunchisqrms_function_type( &::smac::matchfunchisqrms )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("min")=0.0, bp::arg("max")=1.0e+0 ) );
    
    }

    { //::smac::matchfundiff
    
        typedef double ( *matchfundiff_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,double,double );
        
        bp::def( 
            "matchfundiff"
            , matchfundiff_function_type( &::smac::matchfundiff )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("min")=0.0, bp::arg("max")=1.0e+0 ) );
    
    }

    { //::smac::matchfundiffrms
    
        typedef double ( *matchfundiffrms_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,double,double );
        
        bp::def( 
            "matchfundiffrms"
            , matchfundiffrms_function_type( &::smac::matchfundiffrms )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("min")=0.0, bp::arg("max")=1.0e+0 ) );
    
    }

    { //::smac::matchfundist
    
        typedef double ( *matchfundist_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,double,double );
        
        bp::def( 
            "matchfundist"
            , matchfundist_function_type( &::smac::matchfundist )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("min")=0.0, bp::arg("max")=1.0e+0 ) );
    
    }

    { //::smac::matchfundistrms
    
        typedef double ( *matchfundistrms_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,double,double );
        
        bp::def( 
            "matchfundistrms"
            , matchfundistrms_function_type( &::smac::matchfundistrms )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("min")=0.0, bp::arg("max")=1.0e+0 ) );
    
    }

    { //::smac::matchfundot
    
        typedef double ( *matchfundot_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,double,double );
        
        bp::def( 
            "matchfundot"
            , matchfundot_function_type( &::smac::matchfundot )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("min")=0.0, bp::arg("max")=1.0e+0 ) );
    
    }

    { //::smac::matchfundotrms
    
        typedef double ( *matchfundotrms_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,double,double );
        
        bp::def( 
            "matchfundotrms"
            , matchfundotrms_function_type( &::smac::matchfundotrms )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("min")=0.0, bp::arg("max")=1.0e+0 ) );
    
    }

    { //::smac::minusequals
    
        typedef void ( *minusequals_function_type )( ::std::vector< double > &,::std::vector< double > & );
        
        bp::def( 
            "minusequals"
            , minusequals_function_type( &::smac::minusequals )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::multiply
    
        typedef void ( *multiply_function_type )( ::smac::shpdesc_t &,double );
        
        bp::def( 
            "multiply"
            , multiply_function_type( &::smac::multiply )
            , ( bp::arg("arg0"), bp::arg("d") ) );
    
    }

    { //::smac::multiply
    
        typedef void ( *multiply_function_type )( ::std::vector< double > &,double );
        
        bp::def( 
            "multiply"
            , multiply_function_type( &::smac::multiply )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::neighbormap
    
        typedef void ( *neighbormap_function_type )( ::smac::shapedata_t &,double,double,::smac::box_t &,::smac::shapedata_t & );
        
        bp::def( 
            "neighbormap"
            , neighbormap_function_type( &::smac::neighbormap )
            , ( bp::arg("shape"), bp::arg("icut"), bp::arg("ocut"), bp::arg("arg3"), bp::arg("map") ) );
    
    }

    { //::smac::normalize
    
        typedef void ( *normalize_function_type )( ::smac::shpdesc_t & );
        
        bp::def( 
            "normalize"
            , normalize_function_type( &::smac::normalize )
            , ( bp::arg("arg0") ) );
    
    }

    { //::smac::normalize
    
        typedef void ( *normalize_function_type )( ::std::vector< double > & );
        
        bp::def( 
            "normalize"
            , normalize_function_type( &::smac::normalize )
            , ( bp::arg("arg0") ) );
    
    }

    { //::smac::normuball
    
        typedef void ( *normuball_function_type )( ::smac::coordlist_t & );
        
        bp::def( 
            "normuball"
            , normuball_function_type( &::smac::normuball )
            , ( bp::arg("x") ) );
    
    }

    { //::smac::normubox
    
        typedef void ( *normubox_function_type )( ::smac::coordlist_t & );
        
        bp::def( 
            "normubox"
            , normubox_function_type( &::smac::normubox )
            , ( bp::arg("x") ) );
    
    }

    { //::smac::normubox
    
        typedef void ( *normubox_function_type )( ::smac::coordlist_t &,double );
        
        bp::def( 
            "normubox"
            , normubox_function_type( &::smac::normubox )
            , ( bp::arg("x"), bp::arg("arg1") ) );
    
    }

    { //::smac::normusphere
    
        typedef void ( *normusphere_function_type )( ::smac::coordlist_t & );
        
        bp::def( 
            "normusphere"
            , normusphere_function_type( &::smac::normusphere )
            , ( bp::arg("x") ) );
    
    }

    { //::smac::pad3d
    
        typedef void ( *pad3d_function_type )( ::smac::coordlist_t & );
        
        bp::def( 
            "pad3d"
            , pad3d_function_type( &::smac::pad3d )
            , ( bp::arg("x") ) );
    
    }

    { //::smac::pbc
    
        typedef void ( *pbc_function_type )( double &,double,bool );
        
        bp::def( 
            "pbc"
            , pbc_function_type( &::smac::pbc )
            , ( bp::arg("x"), bp::arg("per"), bp::arg("periodic")=(bool)(true) ) );
    
    }

    { //::smac::pbc
    
        typedef void ( *pbc_function_type )( ::smac::coord_t &,::smac::coord_t &,::smac::bool_array_t & );
        
        bp::def( 
            "pbc"
            , pbc_function_type( &::smac::pbc )
            , ( bp::arg("x"), bp::arg("period"), bp::arg("arg2") ) );
    
    }

    { //::smac::perturb
    
        typedef void ( *perturb_function_type )( ::smac::coordlist_t &,double );
        
        bp::def( 
            "perturb"
            , perturb_function_type( &::smac::perturb )
            , ( bp::arg("x"), bp::arg("max") ) );
    
    }

    { //::smac::plgndr
    
        typedef double ( *plgndr_function_type )( int,int,double );
        
        bp::def( 
            "plgndr"
            , plgndr_function_type( &::smac::plgndr )
            , ( bp::arg("l"), bp::arg("m"), bp::arg("x") ) );
    
    }

    { //::smac::plusequals
    
        typedef void ( *plusequals_function_type )( ::std::vector< double > &,::std::vector< double > & );
        
        bp::def( 
            "plusequals"
            , plusequals_function_type( &::smac::plusequals )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::polygon
    
        typedef void ( *polygon_function_type )( int,::smac::coordlist_t & );
        
        bp::def( 
            "polygon"
            , polygon_function_type( &::smac::polygon )
            , ( bp::arg("arg0"), bp::arg("x") ) );
    
    }

    { //::smac::randgauss
    
        typedef double ( *randgauss_function_type )( double,double );
        
        bp::def( 
            "randgauss"
            , randgauss_function_type( &::smac::randgauss )
            , ( bp::arg("mean")=0.0, bp::arg("var")=1.0e+0 ) );
    
    }

    { //::smac::randquaternion
    
        typedef void ( *randquaternion_function_type )( ::std::vector< double > & );
        
        bp::def( 
            "randquaternion"
            , randquaternion_function_type( &::smac::randquaternion )
            , ( bp::arg("q") ) );
    
    }

    { //::smac::rdf
    
        typedef void ( *rdf_function_type )( ::smac::coordlist_t &,::smac::box_t &,::smac::rdf_info &,::smac::function1d_t & );
        
        bp::def( 
            "rdf"
            , rdf_function_type( &::smac::rdf )
            , ( bp::arg("x"), bp::arg("box"), bp::arg("arg2"), bp::arg("gofr") ) );
    
    }

    { //::smac::registericp
    
        typedef void ( *registericp_function_type )( ::smac::coordlist_t &,::smac::coordlist_t &,::smac::arg_t );
        
        bp::def( 
            "registericp"
            , registericp_function_type( &::smac::registericp )
            , ( bp::arg("x"), bp::arg("xref"), bp::arg("arg2")=bp::object() ) );
    
    }

    { //::smac::registerpca
    
        typedef void ( *registerpca_function_type )( ::smac::coordlist_t &,::smac::arg_t );
        
        bp::def( 
            "registerpca"
            , registerpca_function_type( &::smac::registerpca )
            , ( bp::arg("x"), bp::arg("arg1")=bp::object() ) );
    
    }

    { //::smac::registersymmetryaxis
    
        typedef void ( *registersymmetryaxis_function_type )( ::smac::coordlist_t &,::std::vector< double > &,::smac::registersymmetryaxis_info & );
        
        bp::def( 
            "registersymmetryaxis"
            , registersymmetryaxis_function_type( &::smac::registersymmetryaxis )
            , ( bp::arg("x_orig"), bp::arg("q_best"), bp::arg("info") ) );
    
    }

    { //::smac::registerzerocomplexcomonent
    
        typedef double ( *registerzerocomplexcomonent_function_type )( ::smac::coordlist_t &,::smac::fourier_info & );
        
        bp::def( 
            "registerzerocomplexcomonent"
            , registerzerocomplexcomonent_function_type( &::smac::registerzerocomplexcomonent )
            , ( bp::arg("x_orig"), bp::arg("info") ) );
    
    }

    { //::smac::rescale
    
        typedef void ( *rescale_function_type )( ::smac::coordlist_t &,double );
        
        bp::def( 
            "rescale"
            , rescale_function_type( &::smac::rescale )
            , ( bp::arg("x"), bp::arg("s") ) );
    
    }

    { //::smac::rmsassign
    
        typedef void ( *rmsassign_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "rmsassign"
            , rmsassign_function_type( &::smac::rmsassign )
            , ( bp::arg("sd1"), bp::arg("sd2"), bp::arg("arg") ) );
    
    }

    { //::smac::rmsdesc
    
        typedef void ( *rmsdesc_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "rmsdesc"
            , rmsdesc_function_type( &::smac::rmsdesc )
            , ( bp::arg("x"), bp::arg("sd"), bp::arg("arg") ) );
    
    }

    { //::smac::rmsfastassign
    
        typedef void ( *rmsfastassign_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "rmsfastassign"
            , rmsfastassign_function_type( &::smac::rmsfastassign )
            , ( bp::arg("sd1"), bp::arg("sd2"), bp::arg("arg")=bp::object() ) );
    
    }

    { //::smac::rotate
    
        typedef void ( *rotate_function_type )( ::smac::coordlist_t &,double,double,double );
        
        bp::def( 
            "rotate"
            , rotate_function_type( &::smac::rotate )
            , ( bp::arg("x"), bp::arg("rotx"), bp::arg("roty"), bp::arg("rotz") ) );
    
    }

    { //::smac::rotateaa
    
        typedef void ( *rotateaa_function_type )( ::smac::coordlist_t &,double,::smac::coord_t & );
        
        bp::def( 
            "rotateaa"
            , rotateaa_function_type( &::smac::rotateaa )
            , ( bp::arg("x"), bp::arg("angle"), bp::arg("axis") ) );
    
    }

    { //::smac::rotated
    
        typedef void ( *rotated_function_type )( ::smac::coordlist_t &,double,double,double );
        
        bp::def( 
            "rotated"
            , rotated_function_type( &::smac::rotated )
            , ( bp::arg("x"), bp::arg("rotx"), bp::arg("roty"), bp::arg("rotz") ) );
    
    }

    { //::smac::rotateq
    
        typedef void ( *rotateq_function_type )( ::smac::coordlist_t &,::std::vector< double > );
        
        bp::def( 
            "rotateq"
            , rotateq_function_type( &::smac::rotateq )
            , ( bp::arg("x"), bp::arg("Q") ) );
    
    }

    { //::smac::savevarxyz
    
        typedef void ( *savevarxyz_function_type )( char const *,::smac::coordlist_t &,::smac::xyz_info & );
        
        bp::def( 
            "savevarxyz"
            , savevarxyz_function_type( &::smac::savevarxyz )
            , ( bp::arg("filename"), bp::arg("arg1"), bp::arg("arg2") ) );
    
    }

    { //::smac::savexyz
    
        typedef void ( *savexyz_function_type )( char const *,::smac::coordlist_t &,::smac::xyz_info & );
        
        bp::def( 
            "savexyz"
            , savexyz_function_type( &::smac::savexyz )
            , ( bp::arg("filename"), bp::arg("x"), bp::arg("info") ) );
    
    }

    { //::smac::shpdist
    
        typedef void ( *shpdist_function_type )( ::smac::shpdesclist_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "shpdist"
            , shpdist_function_type( &::smac::shpdist )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) );
    
    }

    { //::smac::shpdistA3
    
        typedef void ( *shpdistA3_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "shpdistA3"
            , shpdistA3_function_type( &::smac::shpdistA3 )
            , ( bp::arg("s"), bp::arg("sd"), bp::arg("arg2") ) );
    
    }

    { //::smac::shpdistD2
    
        typedef void ( *shpdistD2_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "shpdistD2"
            , shpdistD2_function_type( &::smac::shpdistD2 )
            , ( bp::arg("s"), bp::arg("sd"), bp::arg("arg2") ) );
    
    }

    { //::smac::shphist
    
        typedef void ( *shphist_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "shphist"
            , shphist_function_type( &::smac::shphist )
            , ( bp::arg("s"), bp::arg("sd"), bp::arg("arg2")=bp::object() ) );
    
    }

    { //::smac::shphist2d
    
        typedef void ( *shphist2d_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "shphist2d"
            , shphist2d_function_type( &::smac::shphist2d )
            , ( bp::arg("s"), bp::arg("sd"), bp::arg("arg2")=bp::object() ) );
    
    }

    { //::smac::shphist3d
    
        typedef void ( *shphist3d_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "shphist3d"
            , shphist3d_function_type( &::smac::shphist3d )
            , ( bp::arg("s"), bp::arg("sd"), bp::arg("arg2")=bp::object() ) );
    
    }

    { //::smac::shphistalign2d
    
        typedef void ( *shphistalign2d_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t &,::smac::shphist_info & );
        
        bp::def( 
            "shphistalign2d"
            , shphistalign2d_function_type( &::smac::shphistalign2d )
            , ( bp::arg("sd1"), bp::arg("sd2"), bp::arg("arg2") ) );
    
    }

    { //::smac::subset
    
        typedef ::smac::coordlist_t ( *subset_function_type )( ::smac::coordlist_t &,::smac::clstr_t & );
        
        bp::def( 
            "subset"
            , subset_function_type( &::smac::subset )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::subtract
    
        typedef void ( *subtract_function_type )( ::smac::shpdesc_t &,::smac::shpdesc_t & );
        
        bp::def( 
            "subtract"
            , subtract_function_type( &::smac::subtract )
            , ( bp::arg("arg0"), bp::arg("arg1") ) );
    
    }

    { //::smac::transcentroid
    
        typedef void ( *transcentroid_function_type )( ::smac::coordlist_t & );
        
        bp::def( 
            "transcentroid"
            , transcentroid_function_type( &::smac::transcentroid )
            , ( bp::arg("x") ) );
    
    }

    { //::smac::translate
    
        typedef void ( *translate_function_type )( ::smac::coordlist_t &,::smac::coord_t const & );
        
        bp::def( 
            "translate"
            , translate_function_type( &::smac::translate )
            , ( bp::arg("x"), bp::arg("x_c") ) );
    
    }

    { //::smac::transorigin
    
        typedef void ( *transorigin_function_type )( ::smac::coordlist_t & );
        
        bp::def( 
            "transorigin"
            , transorigin_function_type( &::smac::transorigin )
            , ( bp::arg("x") ) );
    
    }

    { //::smac::unmap
    
        typedef void ( *unmap_function_type )( ::smac::coordlist_t &,::smac::coord_t &,::smac::box_t & );
        
        bp::def( 
            "unmap"
            , unmap_function_type( &::smac::unmap )
            , ( bp::arg("x"), bp::arg("x_c"), bp::arg("box") ) );
    
    }

    { //::smac::unmapcentroid
    
        typedef void ( *unmapcentroid_function_type )( ::smac::coordlist_t &,::smac::box_t & );
        
        bp::def( 
            "unmapcentroid"
            , unmapcentroid_function_type( &::smac::unmapcentroid )
            , ( bp::arg("x"), bp::arg("box") ) );
    
    }

    { //::smac::untranslate
    
        typedef void ( *untranslate_function_type )( ::smac::coordlist_t &,::smac::coord_t const & );
        
        bp::def( 
            "untranslate"
            , untranslate_function_type( &::smac::untranslate )
            , ( bp::arg("x"), bp::arg("x_c") ) );
    
    }

    { //::smac::voxelize
    
        typedef void ( *voxelize_function_type )( ::smac::coordlist_t &,::smac::voxel_t &,int,int,int,::smac::coord_t );
        
        bp::def( 
            "voxelize"
            , voxelize_function_type( &::smac::voxelize )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("nx"), bp::arg("ny"), bp::arg("nz"), bp::arg("box")=std::vector<double, std::allocator<double> >(0ul) ) );
    
    }

    { //::smac::voxfilterfft3d
    
        typedef void ( *voxfilterfft3d_function_type )( ::smac::voxel_t &,int,int,int );
        
        bp::def( 
            "voxfilterfft3d"
            , voxfilterfft3d_function_type( &::smac::voxfilterfft3d )
            , ( bp::arg("voxel"), bp::arg("arg1"), bp::arg("arg2"), bp::arg("arg3") ) );
    
    }

    { //::smac::voxfiltergauss3d
    
        typedef void ( *voxfiltergauss3d_function_type )( ::smac::voxel_t &,int,int,int,int );
        
        bp::def( 
            "voxfiltergauss3d"
            , voxfiltergauss3d_function_type( &::smac::voxfiltergauss3d )
            , ( bp::arg("voxel"), bp::arg("arg1"), bp::arg("arg2"), bp::arg("arg3"), bp::arg("arg4")=(int)(-0x000000001) ) );
    
    }

    { //::smac::wigner3jcoeff
    
        typedef double ( *wigner3jcoeff_function_type )( ::smac::shpdesc_t & );
        
        bp::def( 
            "wigner3jcoeff"
            , wigner3jcoeff_function_type( &::smac::wigner3jcoeff )
            , ( bp::arg("arg0") ) );
    
    }

    { //::smac::wigner3jdesc
    
        typedef void ( *wigner3jdesc_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "wigner3jdesc"
            , wigner3jdesc_function_type( &::smac::wigner3jdesc )
            , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg") ) );
    
    }

    { //::smac::zerndesc2d
    
        typedef void ( *zerndesc2d_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "zerndesc2d"
            , zerndesc2d_function_type( &::smac::zerndesc2d )
            , ( bp::arg("x"), bp::arg("sd"), bp::arg("arg") ) );
    
    }

    { //::smac::zerndesc3d
    
        typedef void ( *zerndesc3d_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "zerndesc3d"
            , zerndesc3d_function_type( &::smac::zerndesc3d )
            , ( bp::arg("x"), bp::arg("sd"), bp::arg("arg") ) );
    
    }

    { //::smac::zernmom2d
    
        typedef void ( *zernmom2d_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "zernmom2d"
            , zernmom2d_function_type( &::smac::zernmom2d )
            , ( bp::arg("shape"), bp::arg("sd"), bp::arg("arg") ) );
    
    }

    { //::smac::zernmom3d
    
        typedef void ( *zernmom3d_function_type )( ::smac::shapedata_t &,::smac::shpdesc_t &,::smac::arg_t );
        
        bp::def( 
            "zernmom3d"
            , zernmom3d_function_type( &::smac::zernmom3d )
            , ( bp::arg("shape"), bp::arg("sd"), bp::arg("arg") ) );
    
    }
}
